## Условие
Задача. Даны два отсортированных массива $a_1$ ≤ . . . ≤ $a_N$ и
$b_1$ ≤ . . . ≤ $b_M$. Надо слить их в один отсортированный за $O(N + M)$ времени и доппамяти.

## Классический вариант 
1. Заведем указатели на первые элементы массивов $i$ и $j$ .
2. По индексу $i$ + $j$ выпишем меньший из $a_i$ и $b_j$ и сдвинем cоответствующий указатель на один вперед.
3. Так делаем, пока `$i$ < $n$ && $j$  < $m$`.
4. Оставшийся хвост одного из массивов дописываем в конец.

## Случай $N >> M$
тогда нет смысла в классическом алгоритме, так как выгоднее сделать $M$ бинпоисков за $O(\log{N})$ времени каждый.

## Нижняя оценка $Merge$
Нижние оценки доказываются в модели решающих деревьев. В каждом узле вопрос: $(A[i] < B[j])$?. 
- Если да, то элемент $A[i]$ должен получить в итоговом массиве меньший индекс, чем элемент $B[j]$.
- Если нет, то наоборот 

Сколько листьев у такого дерева? Их $C_{N+M}^M$, тогда глубина этого дерева $\log_2{C_{N+M} ^ M}$

### Формула Стирлинга (б/д)
$N! ∼ \sqrt{2\pi N}(\frac{N}{e})^N$

### Нижняя оценка Merge: $\Omega\left(M \log_2 \left(1 + \frac{N}{M}\right)\right)$

### Optimal Merge

Вспомним поиск `lower_bound` в отсортированном массиве. Бинпоиск, делов-то! Будем мыслить не в терминах длины массива, а в терминах позиции, куда вставлять элемент.
#### Galloping search

Пусть $k$ — позиция, куда попадет ответ, а $p = 0$ — номер итерации.

1. Заведем указатель на нулевой элемент массива, сравним с искомым. Если под указателем элемент больший искомого, то победа, иначе идем дальше.
2. Сдвинем указатель на $2^p$. Если уже перескочили, то достаточно запустить обычный бинарный поиск на отрезке $[0, 2^p]$, иначе повтори этот шаг, увеличив номер итерации на единичку.

Время работы: $O(\log k)$.