# Фибоначчиева куча

## Структура кучи

Фибоначчиева куча — это структура данных для реализации очереди с приоритетами, которая оптимизирует выполнение операций с минимальной стоимостью. Она состоит из множества деревьев, каждое из которых является кучей. Основные особенности структуры:

- **Каждое дерево** в куче представляет собой **псевдоконцентрическое дерево Фибоначчи** (с несколькими свойствами, аналогичными дереву поиска), которое хранит элементы, упорядоченные по ключу.
- **Деревья** могут быть произвольной формы, однако они организованы по принципу связи с минимальным корнем.
- **Минимальный элемент** всегда доступен на корне самого маленького дерева.

### Операции

1. **Consolidate** (консолидация) — операция слияния деревьев в куче.
   - После выполнения операции деревья, которые имеют одинаковое количество элементов, сливаются в одно. Это позволяет сбалансировать структуру и уменьшить количество деревьев в куче.
   - Время работы этой операции: \( O(\log n) \), так как количество деревьев ограничено \( O(\log n) \).

2. **DecreaseKey** (уменьшение ключа) — операция, которая позволяет уменьшить значение ключа элемента в куче.
   - Если ключ уменьшается, то элемент перемещается вверх по дереву до тех пор, пока не станет корнем дерева или не нарушит свойство кучи.
   - Время работы операции: \( O(1) \) амортизированное.

### Оценка на \( D(n) \)

#### Оценка для операции Consolidate

Операция Consolidate сливает деревья с одинаковым количеством элементов, таким образом, она обрабатывает деревья с размерами 1, 2, 4, 8, и так далее, что соответствует степеням двойки. Это происходит по следующему принципу:

1. В худшем случае на каждом уровне сливаются деревья с одинаковым числом элементов.
2. Количество деревьев с максимальным числом элементов в куче после операций ограничено логарифмом от числа элементов, т.е. \( O(\log n) \).

Теперь давайте вычислим сложность этой операции.

1. Чтобы в куче было \( n \) элементов, необходимо иметь \( O(\log n) \) деревьев.
2. В процессе консолидации количество деревьев сокращается, слияние происходит за \( O(1) \) для каждого шага. Однако, количество операций слияния для \( O(\log n) \) деревьев можно оценить как \( O(\log n) \).

Таким образом, амортизированная оценка времени для операции Consolidate составляет:
\[
T(\text{Consolidate}) = O(\log n)
\]

#### Оценка для операции DecreaseKey

Операция DecreaseKey заключается в уменьшении ключа элемента и перемещении его вверх по дереву, что осуществляется следующим образом:

1. Если ключ уменьшается, то элемент поднимается вверх по дереву, пока не окажется на корне.
2. В худшем случае операция перемещения по дереву требует \( O(\log n) \) времени, так как дерево имеет высоту \( O(\log n) \).

Однако, **амортизированная сложность** этой операции равна \( O(1) \), поскольку, при выполнении серии операций, дерево может быть перераспределено таким образом, что операция DecreaseKey выполняется быстрее.

Таким образом, амортизированная оценка для операции DecreaseKey:
\[
T(\text{DecreaseKey}) = O(1)
\]

### Итоговая амортизированная сложность

Для фибоначчиевой кучи амортизированная сложность операций:

- **Insert** — \( O(1) \)
- **DeleteMin** — \( O(\log n) \)
- **DecreaseKey** — \( O(1) \)
- **Consolidate** — \( O(\log n) \)

Таким образом, операции с фибоначчиевой кучей в среднем выполняются с амортизированной сложностью, что делает её высокоэффективной структурой данных для очередей с приоритетами.
