# Фибоначчиева куча

Фибоначчиева куча — это структура данных, обеспечивающая эффективное выполнение операций с приоритетной очередью. Она особенно полезна в алгоритмах, таких как алгоритм Дейкстры, благодаря амортизированной сложности операций.

---

## Структура кучи

Фибоначчиева куча представляет собой коллекцию деревьев с минимальным значением, поддерживающих свойства кучи. Основные элементы:
- **Список корней** — двусвязный список деревьев, где каждый узел является корнем дерева.
- **Минимальный элемент** — указатель на узел с минимальным значением.
- **Ранг дерева** — количество детей корня.
- **Узлы**:
  - Узлы дерева имеют указатели на родителя, братьев, детей.
  - Узел содержит флаг $mark$, который указывает, был ли удалён один из его детей. Узел с $mark = true$ может быть удалён при потере второго ребёнка.

### Свойства деревьев:
- Все деревья в куче удовлетворяют свойству кучи: значение в любом узле не превышает значения в его дочерних узлах.
- Ранги деревьев различны. Это свойство поддерживается процедурой **Consolidate**.

---

## Операция: `Consolidate`

### Цель:
Объединить деревья одинакового ранга в одно дерево с рангом на единицу больше, тем самым минимизируя количество деревьев в списке корней.

### Алгоритм:
1. **Инициализация:**
   - Создаётся массив $C$ размером $D(n)$, где $C[i]$ хранит указатель на корень дерева с рангом $i$. Изначально $C[i] = \text{null}$.
2. **Обход списка корней:**
   - Для каждого дерева $T$ в списке корней:
     - Если в $C[T.rank]$ уже есть дерево того же ранга, объединяем деревья:
       - Узел с меньшим значением становится корнем.
       - Второе дерево добавляется в список детей корня.
       - Увеличиваем ранг нового дерева.
       - Повторяем, пока не найдём свободную ячейку в $C$.
     - Если дерево успешно помещено в $C$, обновляем указатель на минимум, если значение нового корня меньше текущего.
3. **Обновление списка корней:**
   - Составляем новый список корней из непустых элементов массива $C$.

### Сложность:
- **Объединение двух деревьев:** $O(1)$ (манипуляция с указателями).
- **Число объединений:** $\leq k - 1$, где $k$ — количество деревьев в начальном списке.
- **Итого:** $O(D(n) + k)$, где $D(n)$ — максимальный ранг дерева в куче.

### Доказательство:
Максимальный ранг $D(n)$ пропорционален $\log n$, так как дерево ранга $k$ должно содержать минимум $F_{k+1}$ узлов (число Фибоначчи). Значит, $D(n) = O(\log n)$, а $k \leq \log n$.

---

## Операция: `ExtractMin`

### Цель:
Удалить минимальный элемент из кучи.

### Алгоритм:
1. **Удаление минимального элемента:**
   - Узел минимального элемента удаляется из списка корней.
   - Все его дети добавляются в список корней.
   - У всех детей обнуляется указатель на родителя ($parent = null$).
2. **Процедура Consolidate:**
   - Запускается для слияния деревьев одинакового ранга.
3. **Обновление указателя на минимум:**
   - Указатель обновляется на минимальный элемент в обновлённом списке корней.

### Сложность:
- **Удаление минимального узла:** $O(1)$.
- **Обнуление указателя на родителя у детей:** $O(\text{rank})$, где $\text{rank}$ — ранг удаляемого узла.
- **Consolidate:** $O(D(n) + k)$, где $D(n) = O(\log n)$ и $k \leq \log n$.
- **Итого:** $O(\log n)$ (амортизированное).

### Доказательство:
- Удаление детей минимального узла и их добавление в список корней выполняется за $O(\text{rank})$. Максимальный ранг ограничен $D(n) = O(\log n)$.
- Операция Consolidate занимает $O(\log n)$, так как объединение деревьев выполняется за $O(1)$, а максимальное количество рангов $D(n)$ пропорционально $\log n$.

---

## Оценка на $D(n)$

### Определение:
$D(n)$ — максимальный ранг дерева на $n$ узлах.

---

### Анализ:

- Минимальное количество узлов $S(k)$ в дереве ранга $k$ удовлетворяет рекуррентному соотношению:
  $S(k) = 2 + \sum_{i=0}^{k-2} S(i).$

- Это число не меньше, чем $F_{k+1}$, где $F_k$ — числа Фибоначчи. Отсюда:
  $S(k) \geq F_{k+1}.$

- Решение уравнения показывает, что $S(k)$ растёт экспоненциально, а $D(n) \sim \log_\phi n$, где $\phi = \frac{1+\sqrt{5}}{2}$ — золотое сечение.

---

### Вывод:
$D(n) = O(\log n).$

---

## Итоговая таблица сложностей операций

| Операция        | Алгоритм                                 | Сложность     |
|-----------------|------------------------------------------|---------------|
| `Consolidate`   | Объединение деревьев                    | $O(\log n)$   |
| `ExtractMin`    | Удаление минимума + Consolidate         | $O(\log n)$   |

---

плюс это также хорошо расписано в https://neerc.ifmo.ru/wiki/index.php?title=%D0%A4%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D0%B8%D0%B5%D0%B2%D0%B0_%D0%BA%D1%83%D1%87%D0%B0
